// Code generated by protoc-gen-go.
// source: cap.proto
// DO NOT EDIT!

/*
Package cap is a generated protocol buffer package.

It is generated from these files:
	cap.proto

It has these top-level messages:
	Cap
	Pool
	IndexInfo
	Timestamp
	ScanQuery
	IndexRow
	Mutation
*/
package cap

import proto "code.google.com/p/goprotobuf/proto"
import json "encoding/json"
import math "math"

// Reference proto, json, and math imports to suppress error if they are not otherwise used.
var _ = proto.Marshal
var _ = &json.SyntaxError{}
var _ = math.Inf

// List of possible CAP commands.
type Command int32

const (
	Command_GetPool        Command = 1
	Command_Stats          Command = 2
	Command_IndexCreate    Command = 3
	Command_IndexDrop      Command = 4
	Command_IndexList      Command = 5
	Command_ScanCount      Command = 6
	Command_ScanExists     Command = 7
	Command_ScanLookup     Command = 8
	Command_ScanRange      Command = 9
	Command_ScanFull       Command = 10
	Command_ScanRangecount Command = 11
	Command_UprMutation    Command = 12
	Command_UprDeletion    Command = 13
	Command_EndCommand     Command = 14
)

var Command_name = map[int32]string{
	1:  "GetPool",
	2:  "Stats",
	3:  "IndexCreate",
	4:  "IndexDrop",
	5:  "IndexList",
	6:  "ScanCount",
	7:  "ScanExists",
	8:  "ScanLookup",
	9:  "ScanRange",
	10: "ScanFull",
	11: "ScanRangecount",
	12: "UprMutation",
	13: "UprDeletion",
	14: "EndCommand",
}
var Command_value = map[string]int32{
	"GetPool":        1,
	"Stats":          2,
	"IndexCreate":    3,
	"IndexDrop":      4,
	"IndexList":      5,
	"ScanCount":      6,
	"ScanExists":     7,
	"ScanLookup":     8,
	"ScanRange":      9,
	"ScanFull":       10,
	"ScanRangecount": 11,
	"UprMutation":    12,
	"UprDeletion":    13,
	"EndCommand":     14,
}

func (x Command) Enum() *Command {
	p := new(Command)
	*p = x
	return p
}
func (x Command) String() string {
	return proto.EnumName(Command_name, int32(x))
}
func (x *Command) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Command_value, data, "Command")
	if err != nil {
		return err
	}
	*x = Command(value)
	return nil
}

// List of possible response status.
type Status int32

const (
	Status_Success   Status = 0
	Status_Error     Status = 1
	Status_EndStatus Status = 2
)

var Status_name = map[int32]string{
	0: "Success",
	1: "Error",
	2: "EndStatus",
}
var Status_value = map[string]int32{
	"Success":   0,
	"Error":     1,
	"EndStatus": 2,
}

func (x Status) Enum() *Status {
	p := new(Status)
	*p = x
	return p
}
func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (x *Status) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Status_value, data, "Status")
	if err != nil {
		return err
	}
	*x = Status(value)
	return nil
}

// Possible inclusion criteria for Scan commands.
type Inclusion int32

const (
	Inclusion_Neither Inclusion = 1
	Inclusion_Low     Inclusion = 2
	Inclusion_High    Inclusion = 3
	Inclusion_Both    Inclusion = 4
)

var Inclusion_name = map[int32]string{
	1: "Neither",
	2: "Low",
	3: "High",
	4: "Both",
}
var Inclusion_value = map[string]int32{
	"Neither": 1,
	"Low":     2,
	"High":    3,
	"Both":    4,
}

func (x Inclusion) Enum() *Inclusion {
	p := new(Inclusion)
	*p = x
	return p
}
func (x Inclusion) String() string {
	return proto.EnumName(Inclusion_name, int32(x))
}
func (x *Inclusion) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Inclusion_value, data, "Inclusion")
	if err != nil {
		return err
	}
	*x = Inclusion(value)
	return nil
}

// List of possible index types to be used while creating index.
type IndexType int32

const (
	IndexType_View         IndexType = 1
	IndexType_Llrb         IndexType = 2
	IndexType_LevelDB      IndexType = 3
	IndexType_RocksDB      IndexType = 4
	IndexType_HyperDB      IndexType = 5
	IndexType_RBTree       IndexType = 6
	IndexType_CBTree       IndexType = 7
	IndexType_EndIndexType IndexType = 8
)

var IndexType_name = map[int32]string{
	1: "View",
	2: "Llrb",
	3: "LevelDB",
	4: "RocksDB",
	5: "HyperDB",
	6: "RBTree",
	7: "CBTree",
	8: "EndIndexType",
}
var IndexType_value = map[string]int32{
	"View":         1,
	"Llrb":         2,
	"LevelDB":      3,
	"RocksDB":      4,
	"HyperDB":      5,
	"RBTree":       6,
	"CBTree":       7,
	"EndIndexType": 8,
}

func (x IndexType) Enum() *IndexType {
	p := new(IndexType)
	*p = x
	return p
}
func (x IndexType) String() string {
	return proto.EnumName(IndexType_name, int32(x))
}
func (x *IndexType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(IndexType_value, data, "IndexType")
	if err != nil {
		return err
	}
	*x = IndexType(value)
	return nil
}

// Type of expression used to evaluate document.
type ExprType int32

const (
	ExprType_Simple      ExprType = 1
	ExprType_JavaScript  ExprType = 2
	ExprType_N1QL        ExprType = 3
	ExprType_EndExprType ExprType = 4
)

var ExprType_name = map[int32]string{
	1: "Simple",
	2: "JavaScript",
	3: "N1QL",
	4: "EndExprType",
}
var ExprType_value = map[string]int32{
	"Simple":      1,
	"JavaScript":  2,
	"N1QL":        3,
	"EndExprType": 4,
}

func (x ExprType) Enum() *ExprType {
	p := new(ExprType)
	*p = x
	return p
}
func (x ExprType) String() string {
	return proto.EnumName(ExprType_name, int32(x))
}
func (x *ExprType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ExprType_value, data, "ExprType")
	if err != nil {
		return err
	}
	*x = ExprType(value)
	return nil
}

// All messages are Cap messages
type Cap struct {
	// CAP message header
	Version  *uint32 `protobuf:"varint,1,req,name=version" json:"version,omitempty"`
	Command  *int32  `protobuf:"varint,2,req,name=command" json:"command,omitempty"`
	Request  *bool   `protobuf:"varint,3,req,name=request" json:"request,omitempty"`
	Status   *int32  `protobuf:"varint,5,opt,name=status" json:"status,omitempty"`
	Opaque   *uint32 `protobuf:"varint,4,opt,name=opaque" json:"opaque,omitempty"`
	Masterid *uint64 `protobuf:"varint,6,opt,name=masterid" json:"masterid,omitempty"`
	// Availability of following payload is determined by `command` type.
	Indexids         []uint32     `protobuf:"varint,9,rep,packed,name=indexids" json:"indexids,omitempty"`
	Pool             *Pool        `protobuf:"bytes,7,opt,name=pool" json:"pool,omitempty"`
	Indexes          []*IndexInfo `protobuf:"bytes,8,rep,name=indexes" json:"indexes,omitempty"`
	Timestamp        []*Timestamp `protobuf:"bytes,10,rep,name=timestamp" json:"timestamp,omitempty"`
	Scanquery        *ScanQuery   `protobuf:"bytes,11,opt,name=scanquery" json:"scanquery,omitempty"`
	Rows             []*IndexRow  `protobuf:"bytes,12,rep,name=rows" json:"rows,omitempty"`
	Mutation         *Mutation    `protobuf:"bytes,13,opt,name=mutation" json:"mutation,omitempty"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Cap) Reset()         { *m = Cap{} }
func (m *Cap) String() string { return proto.CompactTextString(m) }
func (*Cap) ProtoMessage()    {}

func (m *Cap) GetVersion() uint32 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func (m *Cap) GetCommand() int32 {
	if m != nil && m.Command != nil {
		return *m.Command
	}
	return 0
}

func (m *Cap) GetRequest() bool {
	if m != nil && m.Request != nil {
		return *m.Request
	}
	return false
}

func (m *Cap) GetStatus() int32 {
	if m != nil && m.Status != nil {
		return *m.Status
	}
	return 0
}

func (m *Cap) GetOpaque() uint32 {
	if m != nil && m.Opaque != nil {
		return *m.Opaque
	}
	return 0
}

func (m *Cap) GetMasterid() uint64 {
	if m != nil && m.Masterid != nil {
		return *m.Masterid
	}
	return 0
}

func (m *Cap) GetIndexids() []uint32 {
	if m != nil {
		return m.Indexids
	}
	return nil
}

func (m *Cap) GetPool() *Pool {
	if m != nil {
		return m.Pool
	}
	return nil
}

func (m *Cap) GetIndexes() []*IndexInfo {
	if m != nil {
		return m.Indexes
	}
	return nil
}

func (m *Cap) GetTimestamp() []*Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Cap) GetScanquery() *ScanQuery {
	if m != nil {
		return m.Scanquery
	}
	return nil
}

func (m *Cap) GetRows() []*IndexRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

func (m *Cap) GetMutation() *Mutation {
	if m != nil {
		return m.Mutation
	}
	return nil
}

// Provides information about index cluster pool
type Pool struct {
	Nodes            []string `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Pool) Reset()         { *m = Pool{} }
func (m *Pool) String() string { return proto.CompactTextString(m) }
func (*Pool) ProtoMessage()    {}

func (m *Pool) GetNodes() []string {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// IndexInfo is per index data structure that provides system-level meta data
// information for all index managed by the system.
type IndexInfo struct {
	Id               *uint32  `protobuf:"varint,1,req,name=id" json:"id,omitempty"`
	Name             *string  `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	Using            *int32   `protobuf:"varint,3,opt,name=using" json:"using,omitempty"`
	Bucket           *string  `protobuf:"bytes,4,opt,name=bucket" json:"bucket,omitempty"`
	IsPrimary        *bool    `protobuf:"varint,5,opt,name=isPrimary" json:"isPrimary,omitempty"`
	ExprType         *int32   `protobuf:"varint,6,opt,name=exprType" json:"exprType,omitempty"`
	OnExprList       []string `protobuf:"bytes,7,rep,name=onExprList" json:"onExprList,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *IndexInfo) Reset()         { *m = IndexInfo{} }
func (m *IndexInfo) String() string { return proto.CompactTextString(m) }
func (*IndexInfo) ProtoMessage()    {}

func (m *IndexInfo) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

func (m *IndexInfo) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *IndexInfo) GetUsing() int32 {
	if m != nil && m.Using != nil {
		return *m.Using
	}
	return 0
}

func (m *IndexInfo) GetBucket() string {
	if m != nil && m.Bucket != nil {
		return *m.Bucket
	}
	return ""
}

func (m *IndexInfo) GetIsPrimary() bool {
	if m != nil && m.IsPrimary != nil {
		return *m.IsPrimary
	}
	return false
}

func (m *IndexInfo) GetExprType() int32 {
	if m != nil && m.ExprType != nil {
		return *m.ExprType
	}
	return 0
}

func (m *IndexInfo) GetOnExprList() []string {
	if m != nil {
		return m.OnExprList
	}
	return nil
}

// Timestamp is a vector of sequence-number one of each kv vbucket.
type Timestamp struct {
	Timestamp        []uint64 `protobuf:"varint,1,rep,packed,name=timestamp" json:"timestamp,omitempty"`
	Indexid          *uint32  `protobuf:"varint,2,opt,name=indexid" json:"indexid,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Timestamp) Reset()         { *m = Timestamp{} }
func (m *Timestamp) String() string { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()    {}

func (m *Timestamp) GetTimestamp() []uint64 {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *Timestamp) GetIndexid() uint32 {
	if m != nil && m.Indexid != nil {
		return *m.Indexid
	}
	return 0
}

// Used to query index data.
type ScanQuery struct {
	Low              [][]byte `protobuf:"bytes,1,rep,name=low" json:"low,omitempty"`
	High             [][]byte `protobuf:"bytes,2,rep,name=high" json:"high,omitempty"`
	Inclusion        *int32   `protobuf:"varint,3,opt,name=inclusion" json:"inclusion,omitempty"`
	Limit            *int64   `protobuf:"varint,4,opt,name=limit" json:"limit,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *ScanQuery) Reset()         { *m = ScanQuery{} }
func (m *ScanQuery) String() string { return proto.CompactTextString(m) }
func (*ScanQuery) ProtoMessage()    {}

func (m *ScanQuery) GetLow() [][]byte {
	if m != nil {
		return m.Low
	}
	return nil
}

func (m *ScanQuery) GetHigh() [][]byte {
	if m != nil {
		return m.High
	}
	return nil
}

func (m *ScanQuery) GetInclusion() int32 {
	if m != nil && m.Inclusion != nil {
		return *m.Inclusion
	}
	return 0
}

func (m *ScanQuery) GetLimit() int64 {
	if m != nil && m.Limit != nil {
		return *m.Limit
	}
	return 0
}

// Index row that is sent as query result.
type IndexRow struct {
	Key              []byte `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value            []byte `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *IndexRow) Reset()         { *m = IndexRow{} }
func (m *IndexRow) String() string { return proto.CompactTextString(m) }
func (*IndexRow) ProtoMessage()    {}

func (m *IndexRow) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *IndexRow) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// Mutations from projector to indexer.
type Mutation struct {
	Docid            []byte   `protobuf:"bytes,1,req,name=docid" json:"docid,omitempty"`
	Vbucket          *int32   `protobuf:"varint,3,req,name=vbucket" json:"vbucket,omitempty"`
	Vbuuid           *uint64  `protobuf:"varint,4,req,name=vbuuid" json:"vbuuid,omitempty"`
	Sequence         *uint64  `protobuf:"varint,2,req,name=sequence" json:"sequence,omitempty"`
	Keys             [][]byte `protobuf:"bytes,5,rep,name=keys" json:"keys,omitempty"`
	Indexid          []uint32 `protobuf:"varint,6,rep,name=indexid" json:"indexid,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *Mutation) Reset()         { *m = Mutation{} }
func (m *Mutation) String() string { return proto.CompactTextString(m) }
func (*Mutation) ProtoMessage()    {}

func (m *Mutation) GetDocid() []byte {
	if m != nil {
		return m.Docid
	}
	return nil
}

func (m *Mutation) GetVbucket() int32 {
	if m != nil && m.Vbucket != nil {
		return *m.Vbucket
	}
	return 0
}

func (m *Mutation) GetVbuuid() uint64 {
	if m != nil && m.Vbuuid != nil {
		return *m.Vbuuid
	}
	return 0
}

func (m *Mutation) GetSequence() uint64 {
	if m != nil && m.Sequence != nil {
		return *m.Sequence
	}
	return 0
}

func (m *Mutation) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *Mutation) GetIndexid() []uint32 {
	if m != nil {
		return m.Indexid
	}
	return nil
}

func init() {
	proto.RegisterEnum("cap.Command", Command_name, Command_value)
	proto.RegisterEnum("cap.Status", Status_name, Status_value)
	proto.RegisterEnum("cap.Inclusion", Inclusion_name, Inclusion_value)
	proto.RegisterEnum("cap.IndexType", IndexType_name, IndexType_value)
	proto.RegisterEnum("cap.ExprType", ExprType_name, ExprType_value)
}
