// version:
//   TODO: define version.
//
// Cap message:
//   All messages are CAP messages, messages are exchanged between nodes
//   via socket connection as request and response.
//
// command:
//   CAP messages are differentiated by the command field. Command field
//   defines the availablility of rest of the optional payload.
//
// full-duplex:
//   CAP connections are full-duplex, that is, either side can independantly
//   send one or more request and wait for one or more response.
//   Opaque field in the CAP message is used to differentiate simultaneous
//   requests and outstanding response.
//
// Check basic.proto first to learn about basic data primitives used in CAP
// messages.

package cap;

// List of possible CAP commands.
enum Command {
    GetPool        =  1;
    Stats          =  2;
    IndexCreate    =  3;
    IndexDrop      =  4;
    IndexList      =  5;
    ScanCount      =  6;
    ScanExists     =  7;
    ScanLookup     =  8;
    ScanRange      =  9;
    ScanFull       = 10;
    ScanRangecount = 11;
    UprMutation    = 12;
    UprDeletion    = 13;
    EndCommand     = 14;
}

// List of possible response status.
enum Status {
    Success   = 0;
    Error     = 1;
    EndStatus = 2;
}

// Possible inclusion criteria for Scan commands.
enum Inclusion {
    Neither = 1;
    Low     = 2;
    High    = 3;
    Both    = 4;
}

// List of possible index types to be used while creating index.
enum IndexType {
    View         = 1;
    Llrb         = 2;
    LevelDB      = 3;
    RocksDB      = 4;
    HyperDB      = 5;
    RBTree       = 6;
    CBTree       = 7;
    EndIndexType = 8;
}

// Type of expression used to evaluate document.
enum ExprType {
    Simple      = 1;
    JavaScript  = 2;
    N1QL        = 3;
    EndExprType = 4;
}

// All messages are Cap messages
message Cap {
    // CAP message header
    required uint32    version   =  1;  // protocol version
    required int32     command   =  2;  // command that defines rest of the payload
    required bool      request   =  3;  // true - request; false - response
    optional int32     status    =  5;  // present only for response message.
    optional uint32    opaque    =  4;  // differentiate independant request/response
    optional uint64    masterid  =  6;  // generated by master index manager.

    // Availability of following payload is determined by `command` type.
    repeated uint32    indexids  =  9 [packed=true];
    optional Pool      pool      =  7;
    repeated IndexInfo indexes   =  8;
    repeated Timestamp timestamp = 10;
    optional ScanQuery scanquery = 11;
    repeated IndexRow  rows      = 12;
    optional Mutation  mutation  = 13;
}

// Provides information about index cluster pool
message Pool {
    repeated string    nodes = 1; // represented as [host:port] format
}

// IndexInfo is per index data structure that provides system-level meta data
// information for all index managed by the system.
message IndexInfo {
    required uint32 id         = 1; // unique id for active index
    optional string name       = 2; // Name of the index
    optional int32  using      = 3; // indexing algorithm
    optional string bucket     = 4; // bucket for which index is created
    optional bool   isPrimary  = 5; // whether it is primary index
    optional int32  exprType   = 6; // Expression type
    repeated string onExprList = 7; // list of expressions
}

// Timestamp is a vector of sequence-number one of each kv vbucket.
message Timestamp {
    repeated uint64    timestamp = 1 [packed=true];
    optional uint32    indexid   = 2;
}

// Used to query index data.
message ScanQuery {
    repeated bytes low       = 1;
    repeated bytes high      = 2;
    optional int32 inclusion = 3;
    optional int64 limit     = 4;
}

// Index row that is sent as query result.
message IndexRow {
    optional bytes key   = 1;
    optional bytes value = 2;
}

// Mutations from projector to indexer.
message Mutation {
    required bytes  docid    = 1;
    required int32  vbucket  = 3;
    required uint64 vbuuid   = 4;
    required uint64 sequence = 2;
    repeated bytes  keys     = 5;
    repeated uint32 indexid  = 6;
}
