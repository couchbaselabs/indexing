// A rest client to be used with server.
package server

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/couchbaselabs/indexing/api"
	"io/ioutil"
	"net/http"
)

// A notion of catalog on the client side. For most operations we access the
// server - transparently.
type RestClient struct {
	addr  string
	httpc *http.Client
	notic *http.Client
}

// Create a notion of catalog on the client side.
func NewRestClient(addr string) *RestClient {
	return &RestClient{
		addr:  addr,
		httpc: &http.Client{},
		notic: &http.Client{},
	}
}

// Create a new index. If successful, return index-info as returned by the
// server, also the unique id generated by the server.
func (client *RestClient) Create(indexinfo api.IndexInfo) (
	string, api.IndexInfo, error) {

	var body []byte
	var resp *http.Response
	var err error
	var mresp api.IndexMetaResponse
	var serverUuid string

	// Construct request body.
	indexreq := api.IndexRequest{Type: api.CREATE, Indexinfo: indexinfo}
	if body, err = json.Marshal(indexreq); err == nil {
		// Post HTTP request.
		bodybuf := bytes.NewBuffer(body)
		url := client.addr + "/create"
		if resp, err = client.httpc.Post(url, "application/json", bodybuf); err == nil {
			defer resp.Body.Close()
			mresp, err = metaResponse(resp)
			serverUuid, indexinfo = mresp.ServerUuid, mresp.Indexes[0]
		}
	}
	return serverUuid, indexinfo, err
}

// Drop index. `uuid` identies the index to be droped but is unique-id. The
// call returns server's new unique-id.
func (client *RestClient) Drop(uuid string) (string, error) {
	var body []byte
	var err error
	var mresp api.IndexMetaResponse
	var serverUuid string

	// Construct request body.
	index := api.IndexInfo{Uuid: uuid}
	indexreq := api.IndexRequest{Type: api.DROP, Indexinfo: index}
	if body, err = json.Marshal(indexreq); err == nil {
		// Post HTTP request.
		bodybuf := bytes.NewBuffer(body)
		url := client.addr + "/drop"
		if resp, err := client.httpc.Post(url, "application/json", bodybuf); err == nil {
			defer resp.Body.Close()
			mresp, err = metaResponse(resp)
			serverUuid = mresp.ServerUuid
		}
	}
	return serverUuid, err
}

// List of all indexes. if `serverUuid` is same as server's unique-id then
// index-data is not sent back, if it doesn't match or if it is empty, then
// list of all index data is sent back.
func (client *RestClient) List(serverUuid string) (
	string, []api.IndexInfo, error) {

	var err error
	var body []byte
	var mresp api.IndexMetaResponse
	var indexes []api.IndexInfo
	var resp *http.Response

	// Construct request body.
	indexreq := api.IndexRequest{Type: api.LIST, ServerUuid: serverUuid}
	if body, err = json.Marshal(indexreq); err != nil {
		return serverUuid, nil, err
	}

	// Post HTTP request.
	bodybuf := bytes.NewBuffer(body)
	url := client.addr + "/list"
	if resp, err = client.httpc.Post(url, "application/json", bodybuf); err == nil {
		defer resp.Body.Close()
		if mresp, err = metaResponse(resp); err == nil {
			serverUuid = mresp.ServerUuid
			indexes = mresp.Indexes
		}
	}
	return serverUuid, indexes, err
}

// Get Finder interface for the index.
func (client *RestClient) Index(uuid string) (api.IndexInfo, error) {
	var index api.IndexInfo
	var err error

	if _, indexinfos, err := client.List(""); err == nil {
		for _, indexinfo := range indexinfos {
			if indexinfo.Uuid == uuid {
				index = indexinfo
				break
			}
		}
		err = errors.New("Invalid uuid")
	}
	return index, err
}

func (client *RestClient) Trait(index *api.IndexInfo, op interface{}) api.TraitInfo {

	panic("Yet to be implemented")
}

// Scan for index entries.
func (client *RestClient) Scan(index *api.IndexInfo, q api.QueryParams) (
	[]api.IndexRow, error) {

	var body []byte
	var rows []api.IndexRow
	var err error

	// Construct request body.
	indexreq := api.IndexRequest{Type: api.SCAN, Indexinfo: *index, Params: q}
	if body, err = json.Marshal(indexreq); err != nil {
		return nil, err
	}

	// Post HTTP request.
	bodybuf := bytes.NewBuffer(body)
	if resp, err := client.httpc.Post(client.addr+"/scan", "application/json", bodybuf); err == nil {
		defer resp.Body.Close()
		// Gather indexinfo
		indexres := api.IndexScanResponse{}
		if body, err = ioutil.ReadAll(resp.Body); err == nil {
			if err = json.Unmarshal(body, &indexres); err == nil {
				if indexres.Status == api.ERROR {
					err = errors.New(indexres.Errors[0].Msg)
				} else {
					rows = indexres.Rows
				}
			}
		}
	}
	return rows, err
}

func (client *RestClient) Nodes() ([]string, error) {
	var err error
	var body []byte
	var mresp api.IndexMetaResponse
	var nodes []string

	// Construct request body.
	indexreq := api.IndexRequest{Type: api.NODES}
	if body, err = json.Marshal(indexreq); err != nil {
		return nil, err
	}

	// Post HTTP request.
	bodybuf := bytes.NewBuffer(body)
	url := client.addr + "/nodes"
	if resp, err := client.httpc.Post(url, "application/json", bodybuf); err == nil {
		defer resp.Body.Close()
		if mresp, err = metaResponse(resp); err == nil {
			nodes = mresp.Nodes
		}
	}
	return nodes, err
}

// Return a error channel that will send a nil when server changes state or
// will return an error if something goes wrong.
func (client *RestClient) Notify(serverUuid string) chan error {
	errch := make(chan error)
	go client.notifyDaemon(serverUuid, errch)
	return errch
}

func (client *RestClient) notifyDaemon(serverUuid string, errch chan error) {
	var body []byte
	var err error
	var mresp api.IndexMetaResponse
	var resp *http.Response

	indexreq := api.IndexRequest{Type: api.NODES, ServerUuid: serverUuid}
	if body, err = json.Marshal(indexreq); err == nil {
		// Post HTTP request.
		buf := bytes.NewBuffer(body)
		url := client.addr + "/notify"
		resp, err = client.notic.Post(url, "application/json", buf)
		if err == nil {
			mresp, err = metaResponse(resp)
			if err == nil && mresp.Status != api.INVALID_CACHE {
				err = fmt.Errorf("Unexpected status", mresp.Status)
			}
		}
	}
	errch <- err
}

// Gather index meta response from http response.
func metaResponse(resp *http.Response) (api.IndexMetaResponse, error) {
	var body []byte
	var err error

	indexres := api.IndexMetaResponse{}
	if body, err = ioutil.ReadAll(resp.Body); err == nil {
		if err = json.Unmarshal(body, &indexres); err == nil {
			if indexres.Status == api.ERROR {
				err = errors.New(indexres.Errors[0].Msg)
			}
		}
	}
	return indexres, err
}
