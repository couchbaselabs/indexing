// A rest client to be used with server.
package server

import (
	"bytes"
	"encoding/json"
	"errors"
	. "github.com/couchbaselabs/indexing/api"
	"io/ioutil"
	"log"
	"net/http"
)

// A notion of catalog on the client side. For most operations we access the
// server - transparently.
type RestClient struct {
	addr  string
	httpc *http.Client
}

// Create a notion of catalog on the client side.
func NewRestClient(addr string) *RestClient {
	return &RestClient{
		addr:  addr,
		httpc: http.DefaultClient,
	}
}

// Create a new index. If successful, return index-info as returned by the
// server, also the unique id generated by the server.
func (client *RestClient) Create(indexinfo IndexInfo) (
	string, IndexInfo, error) {

	var body []byte
	var resp *http.Response
	var err error
	var mresp IndexMetaResponse
	var serverUuid string

	// Construct request body.
	indexreq := IndexRequest{Type: CREATE, Index: indexinfo}
	if body, err = json.Marshal(indexreq); err == nil {
		// Post HTTP request.
		bodybuf := bytes.NewBuffer(body)
		url := client.addr + "/create"
		log.Printf("Posting %v to URL %v", bodybuf, url)
		if resp, err = client.httpc.Post(url, "application/json", bodybuf); err == nil {
			defer resp.Body.Close()
			mresp, err = metaResponse(resp)
			//FIXME: Do we need to check for err here and return conditionally
			serverUuid, indexinfo = mresp.ServerUuid, mresp.Indexes[0]
		}
	}
	return serverUuid, indexinfo, err
}

// Drop index. `uuid` identies the index to be droped but is unique-id. The
// call returns server's new unique-id.
func (client *RestClient) Drop(uuid string) (string, error) {
	var body []byte
	var err error
	var mresp IndexMetaResponse
	var serverUuid string

	// Construct request body.
	index := IndexInfo{Uuid: uuid}
	indexreq := IndexRequest{Type: DROP, Index: index}
	if body, err = json.Marshal(indexreq); err == nil {
		// Post HTTP request.
		bodybuf := bytes.NewBuffer(body)
		url := client.addr + "/drop"
		log.Printf("Posting %v to URL %v", bodybuf, url)
		if resp, err := client.httpc.Post(url, "application/json", bodybuf); err == nil {
			defer resp.Body.Close()
			mresp, err = metaResponse(resp)
			//FIXME: Do we need to check for err here and return conditionally
			serverUuid = mresp.ServerUuid
		}
	}
	return serverUuid, err
}

// List of all indexes. if `serverUuid` is same as server's unique-id then
// index-data is not sent back, if it doesn't match or if it is empty, then
// list of all index data is sent back.
func (client *RestClient) List(serverUuid string) (
	string, []IndexInfo, error) {

	var err error
	var body []byte
	var mresp IndexMetaResponse
	var indexes []IndexInfo
	var resp *http.Response

	// Construct request body.
	indexreq := IndexRequest{Type: LIST, ServerUuid: serverUuid}
	if body, err = json.Marshal(indexreq); err != nil {
		return serverUuid, nil, err
	}

	// Post HTTP request.
	bodybuf := bytes.NewBuffer(body)
	url := client.addr + "/list"
	log.Printf("Posting %v to URL %v", bodybuf, url)
	if resp, err = client.httpc.Post(url, "application/json", bodybuf); err == nil {
		defer resp.Body.Close()
		if mresp, err = metaResponse(resp); err == nil {
			serverUuid = mresp.ServerUuid
			indexes = mresp.Indexes
		}
	}
	return serverUuid, indexes, err
}

// Get Finder interface for the index.
func (client *RestClient) Index(uuid string) (IndexInfo, error) {
	var index IndexInfo
	var err error

	if _, indexinfos, err := client.List(""); err == nil {
		for _, indexinfo := range indexinfos {
			if indexinfo.Uuid == uuid {
				index = indexinfo
				break
			}
		}
		err = errors.New("Invalid uuid")
	}
	return index, err
}

func (client *RestClient) Trait(index *IndexInfo, op interface{}) TraitInfo {

	panic("Yet to be implemented")
}

// Scan for index entries.
func (client *RestClient) Scan(index *IndexInfo, q QueryParams) (
	[]IndexRow, error) {

	var body []byte
	var rows []IndexRow
	var err error

	// Construct request body.
	indexreq := IndexRequest{Type: SCAN, Index: *index, Params: q}
	if body, err = json.Marshal(indexreq); err != nil {
		return nil, err
	}

	// Post HTTP request.
	bodybuf := bytes.NewBuffer(body)
	url := client.addr + "/scan"
	log.Printf("Posting %v to URL %v", bodybuf, url)
	if resp, err := client.httpc.Post(url, "application/json", bodybuf); err == nil {
		defer resp.Body.Close()
		// Gather indexinfo
		indexres := IndexScanResponse{}
		if body, err = ioutil.ReadAll(resp.Body); err == nil {
			if err = json.Unmarshal(body, &indexres); err == nil {
				if indexres.Status == ERROR {
					err = errors.New(indexres.Errors[0].Msg)
				} else {
					rows = indexres.Rows
				}
			}
		}
	}
	return rows, err
}

func (client *RestClient) Nodes() ([]NodeInfo, error) {
	var err error
	var body []byte
	var mresp IndexMetaResponse
	var nodes []NodeInfo

	// Construct request body.
	indexreq := IndexRequest{Type: NODES}
	if body, err = json.Marshal(indexreq); err != nil {
		return nil, err
	}

	// Post HTTP request.
	bodybuf := bytes.NewBuffer(body)
	url := client.addr + "/nodes"
	log.Printf("Posting %v to URL %v", bodybuf, url)
	if resp, err := client.httpc.Post(url, "application/json", bodybuf); err == nil {
		defer resp.Body.Close()
		if mresp, err = metaResponse(resp); err == nil {
			nodes = mresp.Nodes
		}
	}
	return nodes, err
}

// Return a error channel that will send a nil when server changes state or
// will return an error if something goes wrong.
func (client *RestClient) Notify(serverUuid string) (ResponseStatus, string, error) {

	var body []byte
	var err error
	var mresp IndexMetaResponse
	var resp *http.Response
	var status ResponseStatus

	indexreq := IndexRequest{Type: NOTIFY, ServerUuid: serverUuid}
	if body, err = json.Marshal(indexreq); err == nil {
		// Post HTTP request.
		bodybuf := bytes.NewBuffer(body)
		url := client.addr + "/notify"
		log.Printf("Posting %v to URL %v", bodybuf, url)
		if resp, err = client.httpc.Post(url, "application/json", bodybuf); err == nil {
			defer resp.Body.Close()
			if mresp, err = metaResponse(resp); err == nil {
				serverUuid = mresp.ServerUuid
				status = mresp.Status
			}
		}
	}
	return status, serverUuid, err
}

// Gather index meta response from http response.
func metaResponse(resp *http.Response) (IndexMetaResponse, error) {
	var body []byte
	var err error

	indexres := IndexMetaResponse{}
	if body, err = ioutil.ReadAll(resp.Body); err == nil {
		if err = json.Unmarshal(body, &indexres); err == nil {
			log.Printf("Received raw response %s", string(body))
			if indexres.Status == ERROR {
				err = errors.New(indexres.Errors[0].Msg)
			}
		}
	}
	return indexres, err
}
