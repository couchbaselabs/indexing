// defer goroutine that handles mvcc snapshots. Functionalites of this process
// augments the functionalit of MVCC process.

package btree

import (
    "fmt"
    "sync/atomic"
)

var _ = fmt.Sprintf("keep 'fmt' import during debugging")

const (
    DEFER_ADD byte = iota
    DEFER_DELETE
)

type DEFER struct {
    deferReq chan []interface{}
}

// FIXME deprecated. nobody is this now.
func (wstore *WStore) pingCache(what byte, fpos int64, node Node) {
    wstore.deferReq <- []interface{}{WS_PINGCACHE, what, fpos, node}
}

// Add intermediate key into the KD's ping-cache. FIXME this logic is not
// integrated with the btree algorithm
func (wstore *WStore) pingKey(what byte, fpos int64, key []byte) {
    wstore.deferReq <- []interface{}{WS_PINGKD, what, fpos, key}
}

// Add intermediate docid into the KD's ping-cache. FIXME this logic is not
// integrated with the btree algorithm
func (wstore *WStore) pingDocid(what byte, fpos int64, docid []byte) {
    wstore.deferReq <- []interface{}{WS_PINGKD, what, fpos, docid}
}

// Post a multi-version snapshot, generated by index mutation, to deferr-
// process.
func (wstore *WStore) postMV(mv *MV) {
    wstore.deferReq <- []interface{}{WS_MV, mv}
}

// Synchronize disk snapshot with in-memory snapshot.
func (wstore *WStore) syncSnapshot(minAccess int64) {
    syncChan := make(chan interface{})
    wstore.deferReq <- []interface{}{WS_SYNCSNAPSHOT, minAccess, syncChan}
    <-syncChan
}

func doDefer(wstore *WStore) {
    var cmd []interface{}
    // Following collection objects are used for every cycle of MVCC snapshot
    // synchronization.
    commitQ := make(map[int64]Node)
    recycleQ := make([]int64, 0, wstore.DrainRate*wstore.Maxlevel)
    addKDs := make(map[int64][]byte)
    delKDs := make(map[int64][]byte)
    for {
        cmd = <-wstore.deferReq
        if cmd != nil {
            switch cmd[0].(byte) {

            case WS_PINGCACHE: // FIXME not being used by anyone
                what, fpos, node := cmd[1].(byte), cmd[2].(int64), cmd[3].(Node)
                if what == DEFER_ADD {
                    wstore._pingCache(fpos, node)
                }

            case WS_PINGKD: // FIXME not yet integrated with btree algorithm
                what, fpos, v := cmd[1].(byte), cmd[2].(int64), cmd[3].([]byte)
                kdping := (*map[int64][]byte)(atomic.LoadPointer(&wstore.kdping))
                if what == DEFER_ADD {
                    addKDs[fpos] = v
                    (*kdping)[fpos] = v
                } else if what == DEFER_DELETE {
                    delKDs[fpos] = v
                    delete(*kdping, fpos)
                }

            case WS_MV: // postMV()
                mv := cmd[1].(*MV)
                for _, node := range mv.commits { // update commitQ & ping cache
                    fpos := node.getKnode().fpos
                    commitQ[fpos] = node
                    wstore._pingCache(fpos, node)
                }
                stales := make([]int64, 0, len(mv.stales))
                for _, fpos := range mv.stales {
                    if commitQ[fpos] != nil { // Recyle stalenodes
                        recycleQ = append(recycleQ, fpos)
                        delete(commitQ, fpos) // evict recycled nodes from commitQ
                        wstore._pingCacheEvict(fpos)
                    } else { // stalenodes to be _reclaimed_
                        stales = append(stales, fpos)
                    }
                }
                mv.stales = stales // Only stalenodes that need to be reclaimed

            case WS_SYNCSNAPSHOT: // syncSnapshot()
                minAccess, syncChan := cmd[1].(int64), cmd[2].(chan interface{})
                reclaimQ := make([]int64, 0, wstore.DrainRate)
                offsets := make([]int64, 0, wstore.DrainRate)
                offsets = append(offsets, recycleQ...)
                wstore.recycleCount += int64(len(recycleQ))
                if len(commitQ) > 0 {
                    mv := wstore.mvQ[len(wstore.mvQ)-1]
                    if len(wstore.mvQ) < 1 {
                        panic("If commitQ is dirty, mvQ should also be dirty")
                    }
                    // Actual Reclaim
                    if minAccess == 0 || minAccess > wstore.head.timestamp {
                        skip := 0
                        for _, mvp := range wstore.mvQ {
                            if mvp.timestamp < wstore.head.timestamp {
                                skip += 1
                                reclaimQ = append(reclaimQ, mvp.stales...)
                            } else {
                                break
                            }
                        }
                        wstore.mvQ = wstore.mvQ[skip:]
                    }
                    // Reclaim file-positions into free-list.
                    offsets = append(offsets, reclaimQ...)
                    wstore.reclaimCount += int64(len(reclaimQ))

                    // Adjust commitQ and ping cache before pingpong
                    for _, fpos := range reclaimQ {
                        delete(commitQ, fpos)
                        wstore._pingCacheEvict(fpos)
                    }

                    wstore.flushSnapshot(commitQ, offsets, mv.root)
                    wstore.setSnapShot(offsets, mv.root, mv.timestamp)

                    // Update btree's ping cache
                    for fpos, node := range commitQ {
                        wstore._pingCache(fpos, node)
                    }
                    for _, fpos := range recycleQ {
                        wstore._pingCacheEvict(fpos)
                    }
                    for _, fpos := range reclaimQ {
                        wstore._pingCacheEvict(fpos)
                    }

                    // Update KD's ping cache.
                    kdping := (*map[int64][]byte)(atomic.LoadPointer(&wstore.kdping))
                    for fpos, v := range addKDs {
                        (*kdping)[fpos] = v
                    }
                    for fpos, _ := range delKDs {
                        delete(*kdping, fpos)
                    }

                    //wstore.displayPing()
                    //wstore.checkPingPong()
                }

                // Reset and restart the cycle of snapshot synchronization
                commitQ = make(map[int64]Node)
                recycleQ = make([]int64, 0, wstore.DrainRate*wstore.Maxlevel)
                addKDs = make(map[int64][]byte)
                delKDs = make(map[int64][]byte)
                syncChan <- nil

            case WS_CLOSE: // Quit
                syncChan := cmd[1].(chan interface{})
                syncChan <- nil
            }
        } else {
            break
        }
    }
}
