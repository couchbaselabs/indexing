1. right now every reader is expected to instantiate a Store data-structure
   which will open a new instance of the index/kvfile for reading.

2. when number of nodes in leaf-cache exceeds `MaxLeafCache`, figure out a
   cache eviction algorithm is efficient for btree.

3. I am not sure locking caches for intermediate nodes and leaf nodes for
   readers will have impact on scalability (especially in cases of
   large number of cores).

4. at present count of all entries under a sub-tree or even under the root tree
   had to be computed by walking down all the leaf nodes under the sub-tree.
   can we include another field called `count` inside the intermediate node's
   structure ?

5. define Range() API.

6. right now, remove works only for individual entries identified by
   {key,docid} tuple, modify its specification to remove all entries
   identiefied by {key}.

7. lookup() and other traversal apis that use channel to return back the
   result to caller can used buffered-channel to avoid blocking on mvQ.
